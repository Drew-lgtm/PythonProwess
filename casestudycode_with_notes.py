# -*- coding: utf-8 -*-
"""CaseStudyCodeDirty.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n7EqiFU08uk1r6BRbP0QHI0Q7JWJyUnc
"""

# Main source of my information: https://docs.github.com/en/rest/activity/events?apiVersion=2022-11-28
# I delibaretly left some print statements I used for testing

import requests
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import pandas as pd
from google.colab import userdata
from statistics import mean

def get_github_events(repo_url, api_key, recent_minutes):
    # Extract the repo owner and name from the privided URL
    repo_parts = repo_url.rstrip('/').split('/')
    repo_owner = repo_parts[-2]
    repo_name = repo_parts[-1]

    # Create the GitHub API URL
    events_url = f"https://api.github.com/repos/{repo_owner}/{repo_name}/events"

    # Calculate the time range relative to current time ( return format: 2024-09-01 17:01:14.315262)
    # time_range = int(datetime.utcnow()) - (recent_minutes) --> not working, wrong types
    time_range = datetime.utcnow() - timedelta(minutes=recent_minutes)
    # print(str(time_range))



    # Set up the headers with the API key for authorization as per documentation
    headers = {
        "Authorization": f"token {api_key}"
    }
    # print(events_url, time_range, headers)

    # Make the API request
    response = requests.get(events_url, headers)
    # print(response)

    # Check if the request was successful, return status code if not
    if response.status_code != 200:
        raise Exception(f"Error fetching events: {response.status_code}, {response.text}")

    events = response.json()
    # print(events)
    filtered_events = []
    allowed_events = {'PushEvent', 'PullRequestEvent', 'IssueCommentEvent', 'WatchEvent'}

    # Filter events based on type and time
    for event in events:
        event_type = event.get('type')
        # print(event_type)
        event_time = datetime.strptime(event.get('created_at'), '%Y-%m-%dT%H:%M:%SZ')
        #print(event_time)

        if event_type in allowed_events and event_time >= time_range:
          filtered_events.append(event)

    return filtered_events

# tested repos:
repo_url = "https://github.com/mwiede/jsch"
repo_url = "https://github.com/google/jax"
repo_url = "https://github.com/tensorflow/tensorflow"
repo_url = "https://github.com/pandas-dev/pandas"
repo_url = "https://github.com/donnemartin/saws"
api_key = userdata.get('API_KEY') # generate and supply your own api key as I hid mine via properties
recent_minutes = 28800 #set to view last 28800 minutes of activities
result = get_github_events(repo_url, api_key, recent_minutes) # call the function itself
print(result) # and prnt the result

# Static code for testing - i am leaving it here for you to follow my thoughts and troubleshoot process
# I created some mock events to test
events = [
    {
        "id": "41534860128",
        "type": "IssueCommentEvent",
        "created_at": "2024-09-02T05:56:59Z",
        "payload": {
            "comment": "Test comment"
        }
    },
    {
        "id": "41534860129",
        "type": "PushEvent",
        "created_at": "2024-09-02T06:57:59Z",
        "payload": {
            "commits": [{"message": "Initial commit"}]
        }
    },
    {
        "id": "41534860130",
        "type": "PushEvent",
        "created_at": "2024-09-02T07:58:59Z",
        "payload": {
            "commits": [{"message": "Another commit"}]
        }
    }
]

result = [{'id': '41534860128',
           'type': 'IssueCommentEvent',
           'actor': {'id': 179596036, 'login': 'ramkumar-92', 'display_login': 'ramkumar-92', 'gravatar_id': '', 'url': 'https://api.github.com/users/ramkumar-92', 'avatar_url': 'https://avatars.githubusercontent.com/u/179596036?'}, 'repo': {'id': 265257800, 'name': 'mwiede/jsch', 'url': 'https://api.github.com/repos/mwiede/jsch'}, 'payload': {'action': 'created', 'issue': {'url': 'https://api.github.com/repos/mwiede/jsch/issues/637', 'repository_url': 'https://api.github.com/repos/mwiede/jsch', 'labels_url': 'https://api.github.com/repos/mwiede/jsch/issues/637/labels{/name}', 'comments_url': 'https://api.github.com/repos/mwiede/jsch/issues/637/comments', 'events_url': 'https://api.github.com/repos/mwiede/jsch/issues/637/events', 'html_url': 'https://github.com/mwiede/jsch/issues/637', 'id': 2489182943, 'node_id': 'I_kwDOD8-DSM6UXerf', 'number': 637, 'title': 'Query in Release strategy and Support', 'user': {'login': 'ramkumar-92', 'id': 179596036, 'node_id': 'U_kgDOCrRrBA', 'avatar_url': 'https://avatars.githubusercontent.com/u/179596036?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/ramkumar-92', 'html_url': 'https://github.com/ramkumar-92', 'followers_url': 'https://api.github.com/users/ramkumar-92/followers', 'following_url': 'https://api.github.com/users/ramkumar-92/following{/other_user}', 'gists_url': 'https://api.github.com/users/ramkumar-92/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/ramkumar-92/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/ramkumar-92/subscriptions', 'organizations_url': 'https://api.github.com/users/ramkumar-92/orgs', 'repos_url': 'https://api.github.com/users/ramkumar-92/repos', 'events_url': 'https://api.github.com/users/ramkumar-92/events{/privacy}', 'received_events_url': 'https://api.github.com/users/ramkumar-92/received_events', 'type': 'User', 'site_admin': False}, 'labels': [], 'state': 'closed', 'locked': False, 'assignee': None, 'assignees': [], 'milestone': None, 'comments': 2, 'created_at': '2024-08-27T12:16:45Z', 'updated_at': '2024-09-02T05:56:57Z', 'closed_at': '2024-09-02T05:56:57Z', 'author_association': 'NONE', 'active_lock_reason': None, 'body': 'Hello,\r\n\r\nI am planning to use JSch version 0.2.19 in my application, and I have a couple of questions regarding the release and support strategy:\r\n\r\n1. **Release Strategy**:\r\n   - I noticed that new versions are released approximately every two months. Could you please clarify if this is the standard release cadence for JSch? Is there a fixed schedule or criteria for releasing new versions?\r\n\r\n2. **Long-Term Support**:\r\n   - What is the long-term support policy for version 0.2.19? Specifically, until when can I expect to receive support, including bug fixes or security updates for this version?\r\n   - If I encounter any bugs or issues in version 0.2.19, how should I report them, and what is the typical response time or process for addressing such issues?\r\n\r\nAny insights or additional information regarding the release and support strategy would be greatly appreciated.\r\n\r\nThank you!\r\n', 'reactions': {'url': 'https://api.github.com/repos/mwiede/jsch/issues/637/reactions', 'total_count': 0, '+1': 0, '-1': 0, 'laugh': 0, 'hooray': 0, 'confused': 0, 'heart': 0, 'rocket': 0, 'eyes': 0}, 'timeline_url': 'https://api.github.com/repos/mwiede/jsch/issues/637/timeline', 'performed_via_github_app': None, 'state_reason': 'completed'}, 'comment': {'url': 'https://api.github.com/repos/mwiede/jsch/issues/comments/2323873070', 'html_url': 'https://github.com/mwiede/jsch/issues/637#issuecomment-2323873070', 'issue_url': 'https://api.github.com/repos/mwiede/jsch/issues/637', 'id': 2323873070, 'node_id': 'IC_kwDOD8-DSM6Kg30u', 'user': {'login': 'ramkumar-92', 'id': 179596036, 'node_id': 'U_kgDOCrRrBA', 'avatar_url': 'https://avatars.githubusercontent.com/u/179596036?v=4', 'gravatar_id': '', 'url': 'https://api.github.com/users/ramkumar-92', 'html_url': 'https://github.com/ramkumar-92', 'followers_url': 'https://api.github.com/users/ramkumar-92/followers', 'following_url': 'https://api.github.com/users/ramkumar-92/following{/other_user}', 'gists_url': 'https://api.github.com/users/ramkumar-92/gists{/gist_id}', 'starred_url': 'https://api.github.com/users/ramkumar-92/starred{/owner}{/repo}', 'subscriptions_url': 'https://api.github.com/users/ramkumar-92/subscriptions', 'organizations_url': 'https://api.github.com/users/ramkumar-92/orgs', 'repos_url': 'https://api.github.com/users/ramkumar-92/repos', 'events_url': 'https://api.github.com/users/ramkumar-92/events{/privacy}', 'received_events_url': 'https://api.github.com/users/ramkumar-92/received_events', 'type': 'User', 'site_admin': False}, 'created_at': '2024-09-02T05:56:57Z', 'updated_at': '2024-09-02T05:56:57Z', 'author_association': 'NONE', 'body': 'Hi @norrisjeremy ,\r\n\r\nThanks for your prompt response and I understand the process now. \r\n\r\nThanks,\r\nRamkumar', 'reactions': {'url': 'https://api.github.com/repos/mwiede/jsch/issues/comments/2323873070/reactions', 'total_count': 0, '+1': 0, '-1': 0, 'laugh': 0, 'hooray': 0, 'confused': 0, 'heart': 0, 'rocket': 0, 'eyes': 0}, 'performed_via_github_app': None}}, 'public': True, 'created_at': '2024-09-02T05:56:59Z'}]

# comparing two outputs...
print(type(events))
print("EVENTS: ", events)
print(type(result))
print("RESULT:", result)

# sources
# https://www.w3schools.com/python/pandas/pandas_json.asp
# https://pandas.pydata.org/docs/reference/general_functions.html
# df = pd.DataFrame(events)
df = pd.DataFrame(result)

# print(df.head())

# Count the number of unique event types and the number of occurrences of each type
event_type_counts = df['type'].value_counts()

# Print the results
print("Number of event types:", len(event_type_counts))
print("\nOccurrences of each event type:")
print(event_type_counts)

df['created_at'] = pd.to_datetime(df['created_at'])

# Calculate the average time between the same events
average_time_differences = {}
for event_type in df['type'].unique():
    # Filter events by type and calculate time differences between each other
    event_times = df[df['type'] == event_type]['created_at'].sort_values()
    time_diffs = event_times.diff().dt.total_seconds().dropna()  # .dropna => drop the first NaN

    if len(time_diffs) > 0:  # Check if there are enough time differences to calculate
        average_time_differences[event_type] = mean(time_diffs)
    else:
        average_time_differences[event_type] = None  # Not enough data to calculate

print("\nAverage time between events by type (in seconds):")
for event_type, avg_time in average_time_differences.items():
    print(f"{event_type}: {avg_time}")

# Calculate the average length of commits
commit_message_lengths = []
for index, row in df.iterrows():
    if row['type'] == 'PushEvent' and 'payload' in row and 'commits' in row['payload']:
        for commit in row['payload']['commits']:
            commit_message_lengths.append(len(commit['message']))

# Return average length, return none if no message
if commit_message_lengths:
    average_commit_message_length = round(mean(commit_message_lengths))
else:
    average_commit_message_length = None

print("\nAverage commit message length:")
print(f"{average_commit_message_length} characters")

# Convert the 'created_at' column to datetime format
df['created_at'] = pd.to_datetime(df['created_at'])

# Group the data by date and event type, and count the number of occurrences
df['date'] = df['created_at'].dt.date
event_counts_by_date = df.groupby(['date', 'type']).size().unstack().fillna(0)

# Plot the data
plt.figure(figsize=(10, 6))
for event_type in event_counts_by_date.columns:
    plt.plot(event_counts_by_date.index, event_counts_by_date[event_type], marker='o', label=event_type)

plt.title('TITLE')
plt.xlabel('X')
plt.ylabel('Y')
plt.legend("LEGEND")
plt.grid(True)
plt.show()

event_counts_by_date.plot(kind='area', stacked=True, alpha=0.5, figsize=(10, 6))
plt.show()

event_counts_by_date.plot(kind='bar', stacked=True, figsize=(10, 6))
plt.show()